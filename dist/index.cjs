'use strict';

var fs = require('fs');
var path = require('path');
var child_process = require('child_process');

async function buildProject(options) {
    const cmd = 'dune';
    const args = [
        'build',
        ...(options.buildArgs ?? []),
        options.watch ? '--watch' : null,
        `--display=${options.display ?? 'quiet'}`,
    ].filter((x) => x);

    const printOutput =
        (io, callback = null) =>
        (chunk) => {
            const output = chunk.toString().trimEnd();

            if (options.verbose) {
                process[io].write(output);
            }

            if (typeof callback === 'function') {
                callback(output);
            }
        };

    const child = child_process.spawn(cmd, args);
    const successToken = 'Success, waiting for filesystem changes';

    await new Promise((resolve, reject) => {
        child.on('error', (err) => {
            reject(new Error(err));
        });

        child.stderr?.on(
            'data',
            printOutput('stdout', (output) => {
                if (options.watch && output.includes(successToken)) {
                    resolve();
                }
            }),
        );

        child.on('close', (code) => {
            /**
             * Dune exit statuses:
             *      0: on success
             *      1: if an error happened
             *      130: if it was interrupted by a signal
             */
            if (code != 0) {
                reject(new Error(`Dune process killed. Please restart Vite manually`));
            } else {
                resolve();
            }
        });

        if (options.timeout > 0) {
            setTimeout(() => {
                resolve();
            }, options.timeout);
        }
    });

    return {
        stopWatcher: () => {
            if (!child.killed) {
                const pid = child.pid.toString();
                child.kill();
                const lockedPid = fs.readFileSync(options.lockFile, 'utf-8');
                                
                if (pid === lockedPid) {
                    fs.rmSync(options.lockFile);
                }
            }
        }
    };
}

const suffixRegex = (suffix) => new RegExp(`${suffix.replace('.', '\\.')}$`);

function melangePlugin(options = {}) {
    let root;
    let buildProcess;

    const srcDir = options.src ?? 'src';
    const target = options.target ?? 'output';
    const buildDir = options.buildDir ?? `_build/default/${srcDir}/${target}`;
    const lockFile = options.lockFile ?? path.resolve(`_build/.lock`);

    return {
        name: 'vite-plugin-melange',
        enforce: 'pre',
        async configResolved(config) {
            root = config.root;
            config.mode === 'development';

            const launchingDevServer =
                config.command === 'serve' && !config.inlineConfig.hasOwnProperty('preview');

            const buildingProduction = config.command === 'build';

            const shouldRebuild = launchingDevServer || buildingProduction;

            options.lockFile = lockFile;
            const isLocked = fs.existsSync(options.lockFile);

            options.watch =
                !isLocked && (config.command === 'serve' || Boolean(config.build.watch));

            if (shouldRebuild) {
                buildProcess = await buildProject(options);
            }
        },
        config: (config) => ({
            build: {
                watch: config.build?.watch ? { exclude: ['**/*.re'] } : null,
            },
            server: {
                watch: {
                    ignored: ['**/*.re'],
                },
            },
        }),

        // Map the imports to the ES6 imports generated by Melange.
        // Lets other plugins and vite-internals discover modules inside build folder
        async resolveId(source, importer, options) {
            if (options.isEntry || !importer) return null;
            if (path.isAbsolute(source)) return null

            if (source.endsWith('.re')) {
                const output = buildDir;
                const relativePath = path.relative(root, source);
                const filePath = path.resolve(output, relativePath).replace(suffixRegex('re'), 'js');
                return filePath
            }

            const dirname = path.dirname(importer);

            try {
                // Check if file is bundled under the target's node_modules
                const dir = require.resolve(source, { paths: [dirname] });
                if (dir.includes(buildDir)) {
                    return dir;
                }
                
                return null;
            } catch (ignored) {}

        },

        async closeBundle() {
            buildProcess.stopWatcher();
        },
    };
}

module.exports = melangePlugin;
